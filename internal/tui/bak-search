package tui

import (
	"bytes"
	"context"
	"fmt"
	"strings"

	"github.com/alecthomas/chroma/v2"
	"github.com/alecthomas/chroma/v2/formatters"
	"github.com/alecthomas/chroma/v2/lexers"
	"github.com/alecthomas/chroma/v2/styles"

	"github.com/atotto/clipboard"
	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/fsncps/zeno/internal/db"
)

const maxPreviewLines = 20

// --- Data model ---

type commandItem struct {
	title, desc, code string
	keywords          string
	count             int
	lastUsed          string
	language          string // DISPLAY: CAPS; for lexer we lower()
	formatters        string // formatter_bin from language table
}

func (i commandItem) Title() string       { return i.title }
func (i commandItem) Description() string { return i.desc }
func (i commandItem) FilterValue() string { return i.title + " " + i.desc + " " + i.keywords }

// --- Bubble Tea model ---

type searchModel struct {
	list    list.Model
	details string
	width   int
	height  int
}

// --- highlighting helpers ---

func normalizeLangAlias(lang string) string {
	l := strings.TrimSpace(strings.ToLower(lang))
	switch l {
	case "ps", "pwsh", "powershell", "ps1":
		return "powershell"
	case "js", "node", "nodejs":
		return "javascript"
	case "ts":
		return "typescript"
	case "sh", "shell", "zsh", "bash":
		return "bash"
	case "py":
		return "python"
	case "c#":
		return "csharp"
	case "c++":
		return "cpp"
	case "md", "markdown":
		return "markdown"
	case "yml":
		return "yaml"
	case "tf", "terraform":
		return "hcl"
	default:
		return l
	}
}

func pickLexer(lang, code string) chroma.Lexer {
	if lang != "" {
		if lx := lexers.Get(normalizeLangAlias(lang)); lx != nil {
			return lx
		}
		if lx := lexers.Match(lang); lx != nil {
			return lx
		}
	}
	if lx := lexers.Analyse(code); lx != nil {
		return lx
	}
	return lexers.Fallback
}

func highlightCode(code, lang string) string {
	lx := pickLexer(lang, code)
	it, err := lx.Tokenise(nil, code)
	if err != nil {
		return code
	}
	style := styles.Get("catppuccin-macchiato")
	if style == nil {
		style = styles.Fallback
	}
	var buf bytes.Buffer
	if err := formatters.TTY16m.Format(&buf, style, it); err != nil {
		return code
	}
	return buf.String()
}

func newSearchModel(cmds []commandItem, width, height int) searchModel {
	items := make([]list.Item, len(cmds))
	for i, c := range cmds {
		items[i] = c
	}

	// VISUALS: default delegate (bold title + one dim description line)
	delegate := list.NewDefaultDelegate()
	delegate.ShowDescription = true

	l := list.New(items, delegate, 0, 0)
	l.Title = "Commands"
	l.SetShowStatusBar(false)
	l.SetFilteringEnabled(false) // keep OFF; we do custom fuzzy typing
	l.SetShowHelp(false)
	l.DisableQuitKeybindings()

	initial := ""
	if len(cmds) > 0 {
		initial = cmds[0].code
	}
	// preserve fuzzy: store full corpus; we'll filter in Update()
	return searchModel{
		list:     l,
		allItems: items,
		details:  initial,
		width:    width,
		height:   height,
		// leave m.query empty and don't mirror it into the title to match the old look
	}
}


func (m searchModel) Init() tea.Cmd { return nil }

func (m searchModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		leftWidth := int(0.4 * float32(msg.Width))
		if leftWidth < 20 {
			leftWidth = msg.Width / 2
		}
		m.list.SetSize(leftWidth-2, msg.Height-2)

	case tea.KeyMsg:
		switch msg.String() {
		case "q", "esc", "ctrl+c":
			return m, tea.Quit
		case "enter":
			sel := m.list.SelectedItem().(commandItem)
			_ = clipboard.WriteAll(sel.code)
			fmt.Println("Copied to clipboard")
			return m, tea.Quit
		}
	}

	var cmd tea.Cmd
	m.list, cmd = m.list.Update(msg)
	if sel, ok := m.list.SelectedItem().(commandItem); ok {
		m.details = sel.code
	}
	return m, cmd
}

func (m searchModel) View() string {
	if m.width <= 0 || m.height <= 0 {
		return m.list.View()
	}

	leftWidth := int(0.4 * float32(m.width))
	rightWidth := m.width - leftWidth - 2
	totalHeight := m.height - 2

	paddingLeft := "  "
	border := lipgloss.NewStyle().Border(lipgloss.NormalBorder()).Padding(0, 1)
	footerBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("240")).
		Padding(0, 1).
		Width(rightWidth)
	titleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("205"))

	sel, _ := m.list.SelectedItem().(commandItem)
	hr := paddingLeft + strings.Repeat("â”€", rightWidth-2)

	header := fmt.Sprintf(
		"%s\n\n%s%s\n\n%s%s\n\n%s",
		hr,
		paddingLeft, titleStyle.Render(sel.title),
		paddingLeft, sel.desc,
		hr,
	)

	// preview block
	codeLines := strings.Split(sel.code, "\n")
	if len(codeLines) > maxPreviewLines {
		codeLines = codeLines[:maxPreviewLines]
		codeLines = append(codeLines, "... (truncated)")
	}
	for i, l := range codeLines {
		if len(l) > rightWidth-2 {
			codeLines[i] = l[:rightWidth-2]
		}
	}
	codeBlock := highlightCode(strings.Join(codeLines, "\n"), strings.ToLower(sel.language))

	langDisp := sel.language
	if langDisp == "" {
		langDisp = "-"
	}
	formatters := sel.formatters
	if formatters == "" {
		formatters = "-"
	}

	meta := fmt.Sprintf(
		"Language: %s\nFormatters: %s\nKeywords: %s\nHit count: %d\nLast used: %s",
		langDisp,
		formatters,
		sel.keywords,
		sel.count,
		sel.lastUsed,
	)
	footer := footerBox.Render(meta)

	headerHeight := lipgloss.Height(header)
	footerHeight := lipgloss.Height(footer)
	codeHeight := lipgloss.Height(codeBlock)
	freeSpace := totalHeight - headerHeight - footerHeight - codeHeight
	if freeSpace < 0 {
		freeSpace = 0
	}
	topPad := freeSpace / 2

	rightView := lipgloss.JoinVertical(
		lipgloss.Top,
		header,
		strings.Repeat("\n", topPad),
		codeBlock,
		strings.Repeat("\n", freeSpace-topPad),
		footer,
	)

	listView := border.Width(leftWidth).Render(m.list.View())
	return lipgloss.JoinHorizontal(lipgloss.Top, listView, rightView)
}

// --- Entry point ---

func RunSearch() error {
	ctx := context.Background()
	conn, err := db.Connect(ctx)
	if err != nil {
		return fmt.Errorf("db connect: %w", err)
	}
	defer conn.Close()

	rows, err := conn.Query(`
    SELECT c.ID, c.title, c.description, c.code_md, c.keywords, c.count, c.updated_on,
           UPPER(COALESCE(l.lang_name, '')) AS lang_name,
           COALESCE(l.formatter_bin, '')     AS formatter_bin
      FROM command c
 LEFT JOIN language l ON l.id = c.lang_id
  ORDER BY c.count DESC, c.updated_on DESC`)
	if err != nil {
		return err
	}
	defer rows.Close()

	var cmds []commandItem
	for rows.Next() {
		var id, count int
		var title, desc, code, keywords, updatedOn string
		var langName, formatterBin string
		if err := rows.Scan(&id, &title, &desc, &code, &keywords, &count, &updatedOn, &langName, &formatterBin); err != nil {
			return err
		}
		cmds = append(cmds, commandItem{
			title:      title,
			desc:       desc,
			code:       code,
			keywords:   keywords,
			count:      count,
			lastUsed:   updatedOn,
			language:   langName,
			formatters: formatterBin,
		})
	}
	if err := rows.Err(); err != nil {
		return err
	}
	if len(cmds) == 0 {
		fmt.Println("No commands in database.")
		return nil
	}

	p := tea.NewProgram(newSearchModel(cmds, 0, 0))
	return p.Start()
}

